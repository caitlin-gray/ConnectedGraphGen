import numpy as np
import networkx as nx
import random as rand
import csv
from ConnectedGraphGen import ConnectedNetwork

def waxman_graph2(n, alpha=0.4, beta=0.1, L=None, seed=None, domain=(0, 0, 1, 1)):
    # Adapted from the NetworkX routine to generate Waxman networks with given L based on the euclidian distance
    """Return a Waxman random graph.

    The Waxman random graph model places ``n`` nodes uniformly at random in a
    rectangular domain. Each pair of nodes at Euclidean distance `d` is joined
    by an edge with probability

            p = \alpha \exp(-d / \beta L).

    Parameters
    ----------
    n : int
        Number of nodes
    alpha: float
        Model parameter
    beta: float
        Model parameter
    L : float, optional
        Maximum possible distance between nodes.  If not specified, sqrt 2 is used
    domain : four-tuple of numbers, optional
        Domain size, given as a tuple of the form `(x_min, y_min, x_max,
        y_max)`.

    Returns
    -------
    G: Graph

    References
    ----------
    .. [1]  B. M. Waxman, Routing of multipoint connections.
       IEEE J. Select. Areas Commun. 6(9),(1988) 1617-1622.
    """
    # build graph of n nodes with random positions in the unit square
    rand.seed(seed)
    G = nx.Graph()
    G.add_nodes_from(range(n))
    (xmin,ymin,xmax,ymax)=domain
    for n in G:
        G.node[n]['pos']=(xmin + ((xmax-xmin)*rand.random()),
                          ymin + ((ymax-ymin)*rand.random()))
    if L is None:
        # find maximum distance L between two nodes
        l = 0
        pos = list(nx.get_node_attributes(G,'pos').values())
        while pos:
            x1,y1 = pos.pop()
            for x2,y2 in pos:
                r2 = (x1-x2)**2 + (y1-y2)**2
                if r2 > l:
                    l = r2
        l=np.sqrt(l)
    else:
        # user specified maximum distance
        l = L

    nodes=G.nodes()

    while nodes:
        u = nodes.pop()
        x1,y1 = G.node[u]['pos']
        for v in nodes:
            x2,y2 = G.node[v]['pos']
            r = np.sqrt((x1-x2)**2 + (y1-y2)**2)
            if rand.random() < alpha*np.exp(-r/(beta*l)):
                G.add_edge(u,v)

    return G
def waxman_generator(n,z,s,seed=None):
    # Creates a Waxman graph with specific degree using networkx inbuild routine
    # Parameters
    # ----------
    # n: number of nodes in the graph
    # z: required average node degree
    # s: required s value, where s determines the number of long links to short links. 0<s<10
    #
    # Output:
    # -------
    # G: NetworkX undirected waxman graph
    # alpha: input parameter used for G
    # beta: input parameter used for G

    # Inputs Waxman data from waxman_Gs.dat and to give s and G values that are used to get 'alpha' and 'beta' waxman parameters
    S=[]
    Gs=[]
    with open('waxman_Gs.dat', 'rb') as f:
        reader = csv.reader(f)
        for row in reader:
            if row[0].startswith('#'):
                continue
            S.append(float(row[0]))
            Gs.append(float(row[1]))

    L = np.sqrt(2)
    s = s*1000

    # create the 'alpha'/q vector of values for each s
    alpha_vec = [z/((n-1)*value) for value in Gs]
    beta_vec = [1/(k*L) for k in S]
    q = alpha_vec[s]
    G=waxman_graph2(n,alpha_vec[s],beta_vec[s],L,seed)

    return G,q
def PositionLists(G):
    # Function to extract the x and y co-ordinates from a networkX graph G to speed look up in future processes
    # INPUTS:
    # G : networkX graph
    # create: True if G was generated by networkX routine, false if it was read from file with positions 'x' and 'y'
    # OUTPUTS:
    # positions_x : list of x co-ordinates of nodes (index is node number)
    # positions_y : list of y co-ordinates of nodes (index is node number)

    positions_x=[]
    positions_y=[]

    for i in range(0, len(G)):
        positions_x.append(G.node[i]['pos'][0])
        positions_y.append(G.node[i]['pos'][1])

    return positions_x, positions_y
def ConnectGraph(G):
    # Function to connect a networkx graph G by finding the connected components and adding one link between each component
    # and the largest connected component.
    # INPUTS:
    # G : networkX graph
    # OUTPUTS:
    # G : connected networkX graph
    # components: list of components

    components = [c for c in
                  sorted(nx.connected_components(G), key=len, reverse=True)]  # find the connnected components

    # for each of the smaller components add a link to the largest component (at random)
    for comp in components[1:]:
        # print comp
        i = rand.sample(comp, 1)[0]
        j = rand.sample(components[0], 1)[0]
        G.add_edge(i, j)

    return G, components


n = 100
z = 4
s = 5


# create connected random network. Here we give an example of the Waxman Network
G_m1, q = waxman_generator(n, z, s)         # generate a potentially unconnected random graph
G, components = ConnectGraph(G_m1)          # connect


position_x, position_y = PositionLists(G)   # find lists of coordinates from network (we give an example of extracting
                                                    # this from the networkX Waxman network

def probability(d):
    # probability function for Waxman
    global q, s
    p=q * np.exp(-s * d)
    return p


# MCMC parameter and recording step if desired
number_of_iterations = 100000
record_step = 10000

G_final = ConnectedNetwork(G, position_x, position_y, probability, number_of_iterations, record_step=None)
